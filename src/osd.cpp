
extern "C" {
#include "drm.h"
#include "mavlink.h"
#include "icons/icons.h"
}
#include "osd.h"
#include "osd.hpp"

#include <pthread.h>
#include <map>
#include <vector>
#include <ranges>
#include <memory>
#include <variant>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <deque>
#include <cstdlib> //KILLME
#include <string>
#include <filesystem>
#include <cairo.h>
#include <nlohmann/json.hpp>
#include "spdlog/spdlog.h"
#include <fmt/ranges.h>

#define WFB_LINK_LOST 1
#define WFB_LINK_JAMMED 2

#define PATH_MAX	4096

using json = nlohmann::json;

struct osd_vars osd_vars;

extern uint32_t frames_received;
uint32_t stats_rx_bytes = 0;
struct timespec last_timestamp = {0, 0};
float rx_rate = 0;
int hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
char custom_msg[80];
u_int custom_msg_refresh_count = 0;


double getTimeInterval(struct timespec* timestamp, struct timespec* last_meansure_timestamp) {
  return (timestamp->tv_sec - last_meansure_timestamp->tv_sec) +
       (timestamp->tv_nsec - last_meansure_timestamp->tv_nsec) / 1000000000.;
}

//
// Facts
//

typedef std::map<std::string, std::string> FactTags;


class FactMatcher {
public:
	FactMatcher(std::string name, FactTags tags): name(name), tags(tags) {};
	FactMatcher(std::string name): name(name), tags({}) {};
	std::string name;
	FactTags tags;
};


class FactMeta {
public:
	FactMeta(): name(""), tags({}) {};
	FactMeta(std::string name): name(name), tags({}) {};
	FactMeta(std::string name, FactTags tags): name(name), tags(tags) {};


	std::string getName() { return name; }
	FactTags getTags() { return tags; }

	/**
	 * Returns true if names are equal and all match_tags are defined and have equal value
	 */
	bool match(FactMatcher matcher) {
		if(matcher.name != name) return false;
		for (const auto& [key, match_value] : matcher.tags) {
			if (auto value = tags.find(key); value != tags.end()) {
				if (value->second != match_value) return false;
			} else {
				return false;
			}
		}
		return true;
	}

private:
	std::string name;
	FactTags tags;
};


class Fact {
public:
	Fact(): meta(FactMeta("", {})), type(T_UNDEF) {};
	Fact(FactMeta meta, bool val): meta(meta), value(val), type(T_BOOL) {};
	Fact(FactMeta meta, int val): meta(meta), value(val), type(T_INT) {};
	Fact(FactMeta meta, uint val): meta(meta), value(val), type(T_UINT) {};
	Fact(FactMeta meta, double val): meta(meta), value(val), type(T_DOUBLE) {};
	Fact(FactMeta meta, std::string val): meta(meta), value(val), type(T_STRING) {};

	bool isDefined() {
		return type != T_UNDEF;
	}

	// TODO: try to cast instead of crash
	bool getBoolValue() {
		assertType(T_BOOL);
		return std::get<bool>(value);
	}

	int getIntValue() {
		assertType(T_INT);
		return std::get<int>(value);
	}

	uint getUintValue() {
		assertType(T_UINT);
		return std::get<uint>(value);
	}

	double getDoubleValue() {
		assertType(T_DOUBLE);
		return std::get<double>(value);
	}

	std::string getStrValue() {
		assertType(T_STRING);
		return std::get<std::string>(value);
	}

	bool matches(FactMatcher matcher) {
		return meta.match(matcher);
	}

	std::string getTypeName() {
		return typeName(type);
	}

	std::string getName() {
		return meta.getName();
	}

	FactTags getTags() {
		return meta.getTags();
	}
	
private:
	enum Type {
		T_UNDEF,
		T_BOOL,
		T_INT,
		T_UINT,
		T_DOUBLE,
		T_STRING
	} type = T_UNDEF;
	std::string typeName(Type t) {
		switch(t) {
		case T_UNDEF:
			return "UNDEF";
		case T_BOOL:
			return "BOOL";
		case T_INT:
			return "INT";
		case T_UINT:
			return "UINT";
		case T_DOUBLE:
			return "DOUBLE";
		case T_STRING:
			return "STRING";
		}
		return "UNKNOWN";
	}

	void assertType(Type t) {
		if (t != type) {
			spdlog::error("'{}': requested type of {}, but the actual type is {}",
						  meta.getName(), typeName(t), typeName(type));
			assert(type == t);
		}
	}
	FactMeta meta;
	// TODO: timestamp
	std::variant<
		bool,
		int,
		uint,
		double,
		std::string
		> value;
};



/**
 * Calculates the running average/rate-per-second/min/max over a sliding time window.
 * @param window_size_ms the size of the sliding window in milliseconds
 * @param bucket_size_ms the size of the bucket; structure uses amount of memory
 *        of O(window_size_ms / bucket_size_ms), however large bucket size decreases the precision.
 * NOTE: the code was mostly generated by ChatGPT
 */
class RunningAverage {
public:
    RunningAverage(int window_size_ms, int bucket_size_ms)
        : window_size(window_size_ms), bucket_size(bucket_size_ms), sum(0), count(0) {
		assert(window_size_ms >= bucket_size_ms);
	}

	ulong add(ulong value) {
        // Get the current time in milliseconds
        auto now = std::chrono::steady_clock::now();
        auto current_time = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();

        // Remove outdated buckets
        while (!buckets.empty() && (current_time - std::get<0>(buckets.front()) > window_size)) {
            sum -= std::get<1>(buckets.front());
            count -= std::get<2>(buckets.front());
            buckets.pop_front();
        }

        // Add the value to the current bucket
        if (!buckets.empty() && (current_time - std::get<0>(buckets.back()) < bucket_size)) {
            std::get<1>(buckets.back()) += value;  // Update sum
            std::get<2>(buckets.back()) += 1;       // Update count
            std::get<3>(buckets.back()) = std::min(std::get<3>(buckets.back()), value); // Update min
            std::get<4>(buckets.back()) = std::max(std::get<4>(buckets.back()), value); // Update max
        } else {
            // Create a new bucket with initial min and max set to the current value
            buckets.emplace_back(current_time, value, 1, value, value);
        }

        // Update the running sum and count
        sum += value;
        count++;

        // Return the running average
        return count > 0 ? sum / count : 0;
    }

    double average_over_last_ms(uint last_ms) const {
        ulong last_sum;
        int last_count;
        get_sum_and_count_over_last_ms(last_ms, last_sum, last_count);

        return last_count > 0 ? static_cast<double>(last_sum) / last_count : 0.0;
    }

    double rate_per_second_over_last_ms(uint last_ms) const {
        ulong last_sum;
        int last_count;  // Not used here but calculated for consistency
        get_sum_and_count_over_last_ms(last_ms, last_sum, last_count);
        // Calculate the per-second rate
        double elapsed_seconds = static_cast<double>(last_ms) / 1000.0;
        return elapsed_seconds > 0 ? static_cast<double>(last_sum) / elapsed_seconds : 0.0;
    }

    std::pair<ulong, ulong> min_max_over_last_ms(uint last_ms) const {
        ulong min_value = std::numeric_limits<ulong>::max();
        ulong max_value = std::numeric_limits<ulong>::min();

        // Get the current time in milliseconds
        auto now = std::chrono::steady_clock::now();
        auto current_time = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();

        // Traverse buckets from the most recent to the oldest
        for (auto it = buckets.rbegin(); it != buckets.rend(); ++it) {
            if (current_time - std::get<0>(*it) <= last_ms) {
                min_value = std::min(min_value, std::get<3>(*it));
                max_value = std::max(max_value, std::get<4>(*it));
            } else {
                break;  // Exit loop once we're outside the time window
            }
        }

        return {min_value, max_value};
    }

private:
    void get_sum_and_count_over_last_ms(uint last_ms, ulong& sum_out, int& count_out) const {
        // Get the current time in milliseconds
        auto now = std::chrono::steady_clock::now();
        auto current_time = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();

        sum_out = 0;
        count_out = 0;

        // Traverse buckets from the most recent to the oldest
        for (auto it = buckets.rbegin(); it != buckets.rend(); ++it) {
            if (current_time - std::get<0>(*it) <= last_ms) {
                sum_out += std::get<1>(*it);
                count_out += std::get<2>(*it);
            } else {
                break;  // Exit loop once we're outside the time window
            }
        }
    }

    int window_size; // Time window size in milliseconds
    int bucket_size; // Size of each bucket in milliseconds
    std::deque<std::tuple<long long, ulong, int, ulong, ulong>> buckets; // Each bucket is a tuple (timestamp, sum, count, min, max)
    ulong sum; // Current sum of values in the window
    int count; // Current count of values in the window
};

//
// Widgets
//

class Widget {
public:
	Widget(int pos_x, int pos_y): pos_x(pos_x), pos_y(pos_y) {};
	Widget(int pos_x, int pos_y, uint num_args): pos_x(pos_x), pos_y(pos_y) {
		for (auto i=0; i < num_args; i++) {
			args.push_back(Fact());
		}
	};

	virtual void draw(cairo_t *cr) {};

	virtual void setFact(uint idx, Fact fact) {
		args[idx] = fact;
	}

	int x(cairo_t *cr) {
		cairo_surface_t *target = cairo_get_target(cr);
		int w = cairo_image_surface_get_width(target);
		//int h = cairo_image_surface_get_height(target);
		return (w + pos_x) % w;
	}
	int y(cairo_t *cr) {
		cairo_surface_t *target = cairo_get_target(cr);
		//int w = cairo_image_surface_get_width(target);
		int h = cairo_image_surface_get_height(target);
		return (h + pos_y) % h;
	}
	std::pair<int, int> xy(cairo_t *cr) {
		cairo_surface_t *target = cairo_get_target(cr);
		int w = cairo_image_surface_get_width(target);
		int h = cairo_image_surface_get_height(target);
		return std::pair((w + pos_x) % w, (h + pos_y) % h);
	}

protected:
	int pos_x, pos_y;
	std::vector<Fact> args;
};


class TextWidget: public Widget {
public:
	TextWidget(int pos_x, int pos_y, std::string text): Widget(pos_x, pos_y), text(text) {};

	virtual void draw(cairo_t *cr) {
		auto [x, y] = xy(cr);
		cairo_set_source_rgba(cr, 255.0, 255.0, 255.0, 1);
		cairo_move_to(cr, x, y);
		cairo_show_text(cr, text.c_str());
	}
protected:
	std::string text;
};


class IconTextWidget: public Widget {
public:
	IconTextWidget(int pos_x, int pos_y, cairo_surface_t *icon, std::string text):
		Widget(pos_x, pos_y), text(text), icon(icon) {};

	virtual void draw(cairo_t *cr) {
		auto [x, y] = xy(cr);
		cairo_set_source_surface(cr, icon, x, y - 20);
		cairo_paint(cr);
		cairo_set_source_rgba(cr, 255.0, 255.0, 255.0, 1);
		cairo_move_to(cr, x + 40, y);
		cairo_show_text(cr, text.c_str());
	}

protected:
	std::string text;
	cairo_surface_t *icon;
};


class TplTextWidget: public Widget {
public:
	TplTextWidget(int pos_x, int pos_y, std::string tpl, uint num_args):
		Widget(pos_x, pos_y, num_args), tpl(tpl), num_args(num_args) {};

	virtual void draw(cairo_t *cr) {
		auto [x, y] = xy(cr);
		std::unique_ptr<std::string> msg = render_tpl();
		cairo_set_source_rgba(cr, 255.0, 255.0, 255.0, 1);
		cairo_move_to(cr, x, y);
		cairo_show_text(cr, msg->c_str());
	}

protected:
	std::unique_ptr<std::string> render_tpl() {
		return render_tpl(tpl, args);
	}
	std::unique_ptr<std::string> render_tpl(std::string tpl, std::vector<Fact> args) {
		bool at_placeholder = false;
		int fact_i = 0;
		Fact *fact;
		std::unique_ptr<std::string> msg(new std::string);
		for(char& c : tpl) {
			if (c == '%') {
				at_placeholder = true;
			} else if (!at_placeholder) {
				msg->push_back(c);
			} else if (at_placeholder && c == '%') {
				msg->push_back('%');
				at_placeholder = false;
			} else if (at_placeholder) {
				at_placeholder = false;
				fact = &args[fact_i];
				if (!fact->isDefined()) {
					msg->push_back('?');
					fact_i++;
					continue;
				}
				switch (c) {
				case 'b':
					{
						msg->push_back(fact->getBoolValue() ? 't' : 'f');
						break;
					}
				case 'd':
				case 'i':
					{
						msg->append(std::to_string(fact->getIntValue()));
						break;
					}
				case 'u':
					{
						msg->append(std::to_string(fact->getUintValue()));
						break;
					}
				case 'f':
					{
						msg->append(std::to_string(fact->getDoubleValue()));
						break;
					}
				case 's':
					{
						msg->append(fact->getStrValue());
						break;
					}
				default:
					{
						msg->push_back('?');
					}
				}
				fact_i++;
			}
		}
		return msg;
	}

protected:
	std::string tpl;
	uint num_args;
};


class IconTplTextWidget: public TplTextWidget {
public:
	IconTplTextWidget(int pos_x, int pos_y, cairo_surface_t *icon, std::string tpl, uint num_args):
		TplTextWidget(pos_x, pos_y, tpl, num_args), icon(icon) {};

	virtual void draw(cairo_t *cr) {
		auto [x, y] = xy(cr);
		std::unique_ptr<std::string> msg = render_tpl();
		cairo_set_source_surface(cr, icon, x, y - 20);
		cairo_paint(cr);
		cairo_set_source_rgba(cr, 255.0, 255.0, 255.0, 1);
		cairo_move_to(cr, x + 40, y);
		cairo_show_text(cr, msg->c_str());
	}

protected:
	cairo_surface_t *icon;
};

//
// Specific widgets
//

class DvrStatusWidget: public IconTextWidget {
public:
	DvrStatusWidget(int pos_x, int pos_y, cairo_surface_t *icon, std::string text) :
		IconTextWidget(pos_x, pos_y, icon, text) {
		args.push_back(Fact());
	};

	void draw(cairo_t *cr) {
		if(args[0].isDefined() && args[0].getBoolValue()) {
			auto [x, y] = xy(cr);
			cairo_save(cr);
			cairo_set_source_surface(cr, icon, x, y - 20);
			cairo_paint(cr);
			cairo_set_source_rgba(cr, 255.0, 0.0, 0.0, 1);
			cairo_move_to(cr, x + 40, y);
			cairo_show_text(cr, text.c_str());
			cairo_restore(cr);
		}
	}
};

class VideoWidget: public IconTplTextWidget {
public:
  VideoWidget(int pos_x, int pos_y, uint window_size_ms, uint bucket_size_ms,
              cairo_surface_t *icon, std::string tpl, uint num_args) :
		IconTplTextWidget(pos_x, pos_y, icon, tpl, num_args),
		fps(window_size_ms, bucket_size_ms) {};

	virtual void setFact(uint idx, Fact fact) {
		if (idx == 0) {
			// replace the value with its increment rate per-second
			uint num_frames = fact.getUintValue(); // should be always '1'
			fps.add((ulong)num_frames);
			args[idx] = Fact(FactMeta("video_fps"), (uint)fps.rate_per_second_over_last_ms(1000));
		} else {
			args[idx] = fact;
		}
	}

private:
	RunningAverage fps;
};

// FIXME: incorrect!
class VideoBitrateWidget: public IconTplTextWidget {
public:
  VideoBitrateWidget(int pos_x, int pos_y, uint window_size_ms, uint bucket_size_ms,
					 cairo_surface_t *icon, std::string tpl, uint num_args) :
		IconTplTextWidget(pos_x, pos_y, icon, tpl, num_args),
		bps(window_size_ms, bucket_size_ms) {
	  assert(num_args == 1);
  };

	virtual void setFact(uint idx, Fact fact) {
		assert(idx == 0);
		// replace the value with its increment rate per-second
		uint num_bytes = fact.getUintValue();
		bps.add((ulong)num_bytes);
		// wtf is 125000.0? Why not (1024 * 1024?)
		args[idx] = Fact(FactMeta("video_mbps"), bps.rate_per_second_over_last_ms(1000) / 125000.0);
	}

private:
	RunningAverage bps;
};


class Osd {
public:
	void loadConfig(json cfg) {
		json obj;
		if (!cfg.contains("format")) {
			spdlog::error("OSD config doesn't have 'format' key");
			return;
		}
		if (!cfg.contains("widgets")) {
			//|| cfg["widgets"].type() != json::value_t::array)
			spdlog::error("OSD config doesn't have 'widgets' key");
			return;
		}
		std::filesystem::path assets_dir(".");
		if (cfg.contains("assets_dir")) {
			assets_dir = cfg.at("assets_dir").template get<std::filesystem::path>();
		}
		json widgets_j = cfg.at("widgets");
		for (json widget_j : widgets_j) {
			if(!(widget_j.contains("name") || widget_j.contains("type") || widget_j.contains("x") ||
				 widget_j.contains("y") || widget_j.contains("facts"))) {
				spdlog::error("Missing required key name/type/x/y/facts");
				return;
			}
			auto name = widget_j.at("name").template get<std::string>();
			auto type = widget_j.at("type").template get<std::string>();
			auto x = widget_j.at("x").template get<int>();
			auto y = widget_j.at("y").template get<int>();
			std::vector<FactMatcher> matchers;
			for(json matcher_j : widget_j.at("facts")) {
				auto matcher_name = matcher_j.at("name").template get<std::string>();
				FactTags tags;
				if (matcher_j.contains("tags")) {
					for (auto& [key, value] : matcher_j.at("tags").items()) {
						tags.insert({key, value});
					}
				}
				matchers.push_back(FactMatcher(matcher_name, tags));
			}
			if (type == "TextWidget") {
				addWidget(new TextWidget(x, y, widget_j.at("text").template get<std::string>()),
						  matchers);
			} else if (type == "TplTextWidget") {
				auto tpl = widget_j.at("template").template get<std::string>();
				addWidget(new TplTextWidget(x, y, tpl, (uint)matchers.size()), matchers);
			} else if(type == "IconTplTextWidget") {
				auto tpl = widget_j.at("template").template get<std::string>();
				auto icon_path = widget_j.at("icon_path").template get<std::filesystem::path>();
				cairo_surface_t *icon = openIcon(name, assets_dir, icon_path);
				if (icon == NULL) break;
				addWidget(new IconTplTextWidget(x, y, icon, tpl, (uint)matchers.size()), matchers);
			} else if(type == "DvrStatusWidget") {
				auto text = widget_j.at("text").template get<std::string>();
				auto icon_path = widget_j.at("icon_path").template get<std::filesystem::path>();
				cairo_surface_t *icon = openIcon(name, assets_dir, icon_path);
				if (icon == NULL) break;
				addWidget(new DvrStatusWidget(x, y, icon, text), matchers);
			} else if(type == "VideoWidget") {
				auto tpl = widget_j.at("template").template get<std::string>();
				auto icon_path = widget_j.at("icon_path").template get<std::filesystem::path>();
				uint window_size_s = widget_j.at("per_second_window_s").template get<uint>();
				uint bucket_size_ms = widget_j.at("per_second_bucket_ms").template get<uint>();;
				cairo_surface_t *icon = openIcon(name, assets_dir, icon_path);
				if (icon == NULL) break;
				addWidget(new VideoWidget(x, y, window_size_s * 1000, bucket_size_ms,
										  icon, tpl, (uint)matchers.size()),
						  matchers);
			} else if(type == "VideoBitrateWidget") {
				auto tpl = widget_j.at("template").template get<std::string>();
				auto icon_path = widget_j.at("icon_path").template get<std::filesystem::path>();
				uint window_size_s = widget_j.at("per_second_window_s").template get<uint>();
				uint bucket_size_ms = widget_j.at("per_second_bucket_ms").template get<uint>();;
				cairo_surface_t *icon = openIcon(name, assets_dir, icon_path);
				if (icon == NULL) break;
				addWidget(new VideoBitrateWidget(x, y, window_size_s * 1000, bucket_size_ms,
												 icon, tpl, (uint)matchers.size()),
						  matchers);
			} else {
				spdlog::warn("Widget '{}': unknown type: {}", name, type);
			}
		}
	}

	Osd *addWidget(Widget *widget, std::vector<FactMatcher> param_matchers) {
		uint arg_idx = 0;
		widgets.push_back(widget);
		for (auto matcher : param_matchers) {
			matchers.push_back(std::make_tuple(matcher, widget, arg_idx));
			arg_idx++;
		}
		return this;
	};

	void draw(cairo_t *cr) {
		for(auto &widget : widgets)
			widget->draw(cr);
	};

	void setFact(Fact fact) {
		for (auto [matcher, widget, arg_idx] : matchers) {
			if (fact.matches(matcher)) {
				widget->setFact(arg_idx, fact);
			}
		}
	};

private:

	cairo_surface_t *openIcon(std::string widget_name, std::filesystem::path base_path,
							  std::filesystem::path icon_path) {
		if (icon_path.is_relative()) {
			icon_path = base_path / icon_path;
		}
		cairo_surface_t *icon = cairo_image_surface_create_from_png(icon_path.c_str());
		if (cairo_surface_status(icon) != CAIRO_STATUS_SUCCESS) {
			std::string status("OTHER_ERROR");
			switch (cairo_surface_status(icon)) {
			case CAIRO_STATUS_NULL_POINTER:
				status = "NULL_POINTER";
				break;
			case CAIRO_STATUS_NO_MEMORY:
				status = "NO_MEMORY";
				break;
			case CAIRO_STATUS_READ_ERROR:
				status = "READ_ERROR";
				break;
			case CAIRO_STATUS_INVALID_CONTENT:
				status = "INVALID_CONTENT";
				break;
			case CAIRO_STATUS_INVALID_FORMAT:
				status = "INVALID_FORMAT";
				break;
			case CAIRO_STATUS_INVALID_VISUAL:
				status = "INVALID_VISUAL";
				break;
			};
			spdlog::error("Widget '{}': Can't open icon '{}': {}",
						  widget_name, icon_path.string(), status);
			return NULL;
		}
		return icon;
	}

	std::vector<Widget *> widgets;
	std::vector<std::tuple<FactMatcher, Widget *, uint>> matchers;
};


std::queue<Fact> fact_queue;
std::mutex mtx;
std::condition_variable cv;


cairo_surface_t *fps_icon;
cairo_surface_t *lat_icon;
cairo_surface_t* net_icon;
cairo_surface_t* sdcard_icon;

pthread_mutex_t osd_mutex;

void modeset_paint_buffer(struct modeset_buf *buf, Osd *osd) {
	unsigned int j,k,off;
	cairo_t* cr;
	cairo_surface_t *surface;
	char msg[80];
	memset(msg, 0x00, sizeof(msg));

	int osd_x = buf->width - 300;
	surface = cairo_image_surface_create_for_data(buf->map, CAIRO_FORMAT_ARGB32, buf->width, buf->height, buf->stride);
	cr = cairo_create (surface);

	// https://www.cairographics.org/FAQ/#clear_a_surface
	cairo_save(cr);
	cairo_set_operator(cr, CAIRO_OPERATOR_CLEAR);
	cairo_paint(cr);
	cairo_restore(cr);

	cairo_select_font_face (cr, "Roboto", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
	cairo_set_font_size (cr, 20);

	osd->draw(cr);

	if (osd_vars.enable_video || osd_vars.enable_wfbng ) {
		// stats height
		int stats_top_margin = 5;
		int stats_row_height = 33;
		int stats_height = 30;
		int row_count = 0;
		if (osd_vars.enable_recording) {
			stats_height+=stats_row_height;
		}
		if (osd_vars.enable_video) {
			stats_height+=stats_row_height*2;
			if (osd_vars.enable_latency) {
				stats_height+=stats_row_height;
			}
		}
		if (osd_vars.enable_wfbng) {
			stats_height+=stats_row_height;
		} 

		cairo_set_source_rgba(cr, 0, 0, 0, 0.4); // R, G, B, A
		cairo_rectangle(cr, osd_x, 0, 300, stats_height); 
		cairo_fill(cr);
		

		if (osd_vars.enable_video) {
			row_count++;
			cairo_set_source_surface (cr, fps_icon, osd_x+22, stats_top_margin+stats_row_height-19);
			cairo_paint(cr);
			cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
			cairo_move_to (cr,osd_x+60, stats_top_margin+stats_row_height);
			sprintf(msg, "%d fps | %dx%d", osd_vars.current_framerate, osd_vars.video_width, osd_vars.video_height);
			cairo_show_text (cr, msg);

			if (osd_vars.enable_latency) {
				row_count++;
				cairo_set_source_surface (cr, lat_icon, osd_x+22, stats_top_margin+row_count*stats_row_height-19);
				cairo_paint (cr);
				cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
				cairo_move_to (cr,osd_x+60, stats_top_margin+stats_row_height*2);
				sprintf(msg, "%.2f ms (%.f, %.f)", osd_vars.latency_avg, osd_vars.latency_min, osd_vars.latency_max);
				cairo_show_text (cr, msg);
			}
			
			// Video Link Elements
			double avg_bw = 0;
			int avg_cnt = 0;
			for (int i = osd_vars.bw_curr; i<(osd_vars.bw_curr+10); ++i) {
				int h = osd_vars.bw_stats[i%10]/10000 * 1.2;
				if (h<0) {
					h = 0;
				}
				if (osd_vars.bw_stats[i%10]>0) {
					avg_bw += osd_vars.bw_stats[i%10];
					avg_cnt++;
				}
			}
			avg_bw = avg_bw / avg_cnt;
			if (avg_bw < 1000) {
				sprintf(msg, "%.2f Kbps", avg_bw / 125 );
			} else {
				sprintf(msg, "%.2f Mbps", avg_bw / 125000 );
			}
			row_count++;
			cairo_set_source_surface (cr, net_icon, osd_x+22, stats_top_margin+row_count*stats_row_height-19);
			cairo_paint (cr);
			cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
			cairo_move_to (cr, osd_x+60, stats_top_margin+stats_row_height*row_count);
			cairo_show_text (cr, msg);
		}

		// WFB-ng Elements
		if (osd_vars.enable_wfbng) {
			cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
			sprintf(msg, "WFB %3d F%d L%d", osd_vars.wfb_rssi, osd_vars.wfb_fec_fixed, osd_vars.wfb_errors);
			// //TODO (gehee) Only getting WFB_LINK_LOST when testing.
			// if (osd_vars.wfb_flags & WFB_LINK_LOST) {
			// 		sprintf(msg, "%s (LOST)", msg);
			// } else if (osd_vars.wfb_flags & WFB_LINK_JAMMED) {
			// 		sprintf(msg, "%s (JAMMED)", msg);
			// }
			row_count++;
			cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
			cairo_move_to(cr, osd_x+25, stats_top_margin+stats_row_height*row_count);
			cairo_show_text(cr, msg);
		}

		// Recording
		if (osd_vars.enable_recording) {
			
			// Sets the source pattern within cr to a translucent color. This color will then be used for any subsequent drawing operation until a new source pattern is set.
			// did not change anything
			cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
			sprintf(msg, "Recording");
						
			row_count++;
			// This is a convenience function for creating a pattern from surface and setting it as the source in cr with cairo_set_source().
			// if when we have an icon
			cairo_set_source_surface (cr, sdcard_icon, osd_x+22, stats_top_margin+row_count*stats_row_height-19);
			cairo_paint (cr);

			// // set to red font
			cairo_set_source_rgba (cr, 255.0, 0.0, 0.0, 1);

			// Begin a new sub-path. After this call the current point will be (x, y)
			cairo_move_to (cr, osd_x+60, stats_top_margin+stats_row_height*row_count);
			cairo_show_text (cr, msg);
		}
	}

	//display custom message
	if (osd_custom_message) {
		FILE *file = fopen("/run/pixelpilot.msg", "r");
		if (file != NULL) {

			if (fgets(custom_msg, sizeof(custom_msg), file) == NULL) {
				perror("Error reading from file");
				fclose(file);
			}
			fclose(file);
			if (unlink("/run/pixelpilot.msg") != 0) {
				perror("Error deleting the file");
			}
			custom_msg_refresh_count = 1;
		}
		if (custom_msg_refresh_count > 0) {

			if (custom_msg_refresh_count++ > 5) custom_msg_refresh_count=0;

			size_t msg_length = strlen(custom_msg);

			// Ensure null termination at the 80th position to prevent overflow
			custom_msg[79] = '\0';

			// Find the first newline character, if it exists
			char *newline_pos = strchr(custom_msg, '\n');
			if (newline_pos != NULL) {
				*newline_pos = '\0';  // Null-terminate at the newline
			}

			// Measure the text width
			cairo_text_extents_t extents;
			cairo_text_extents(cr, custom_msg, &extents);

			// Calculate the position to center the text horizontally
			double x = (buf->width / 2) - (extents.width / 2);
			double y = (buf->height / 2);

			// Set the position and draw the text
			cairo_move_to(cr, x, y);
			cairo_show_text(cr, custom_msg);
		}
	}	

	if (!osd_vars.enable_telemetry){
		return;
	}

	cairo_set_source_rgba (cr, 255.0, 255.0, 255.0, 1);
	// Mavlink elements
	uint32_t x_center = buf->width / 2;
	if (osd_vars.telemetry_level > 1){
		// OSD telemetry
		sprintf(msg, "ALT:%.00fM", osd_vars.telemetry_altitude);
		cairo_move_to(cr, x_center + (20) + 260, buf->height / 2 - 8);
		cairo_show_text(cr, msg);
		sprintf(msg, "SPD:%.00fKM/H", osd_vars.telemetry_gspeed);
		cairo_move_to(cr, x_center - (16 * 3) - 360, buf->height / 2 - 8);
		cairo_show_text(cr, msg);
		sprintf(msg, "VSPD:%.00fM/S", osd_vars.telemetry_vspeed);
		cairo_move_to(cr, x_center + (20) + 260, buf->height / 2 + 22);
		cairo_show_text(cr, msg);
	}

    sprintf(msg, "BAT:%.02fV", osd_vars.telemetry_battery / 1000);
    cairo_move_to(cr, 40, buf->height - 30);
    cairo_show_text(cr, msg);
    sprintf(msg, "CONS:%.00fmAh", osd_vars.telemetry_current_consumed);
    cairo_move_to(cr, 40, buf->height - 60);
    cairo_show_text(cr, msg);
    sprintf(msg, "CUR:%.02fA", osd_vars.telemetry_current / 100);
    cairo_move_to(cr, 40, buf->height - 90);
    cairo_show_text(cr, msg);
    sprintf(msg, "THR:%.00f%%", osd_vars.telemetry_throttle);
    cairo_move_to(cr, 40, buf->height - 120);
    cairo_show_text(cr, msg);
    sprintf(msg, "TEMP:%.00fC", osd_vars.telemetry_raw_imu/100);
    cairo_move_to(cr, 40, buf->height - 150);
    cairo_show_text(cr, msg);
    
	if (osd_vars.telemetry_level > 1){
		sprintf(msg, "SATS:%.00f", osd_vars.telemetry_sats);
		cairo_move_to(cr,buf->width - 140, buf->height - 30);
		cairo_show_text(cr, msg);
		sprintf(msg, "HDG:%.00f", osd_vars.telemetry_hdg);
		cairo_move_to(cr,buf->width - 140, buf->height - 120);
		cairo_show_text(cr, msg);
		sprintf(osd_vars.c1, "%.00f", osd_vars.telemetry_lat);

		if (osd_vars.telemetry_lat < 10000000) {
			insertString(osd_vars.c1, "LAT:0.", 0);
		}

		if (osd_vars.telemetry_lat > 9999999) {
			if (numOfChars(osd_vars.c1) == 8) {
				insertString(osd_vars.c1, ".", 1);
			} else {
				insertString(osd_vars.c1, ".", 2);
			}
			insertString(osd_vars.c1, "LAT:", 0);
		}
		cairo_move_to(cr, buf->width - 240, buf->height - 90);
		cairo_show_text(cr,  osd_vars.c1);

		sprintf(osd_vars.c2, "%.00f", osd_vars.telemetry_lon);
		if (osd_vars.telemetry_lon < 10000000) {
			insertString(osd_vars.c2, "LON:0.", 0);
		}
		if (osd_vars.telemetry_lon > 9999999) {
			if (numOfChars(osd_vars.c2) == 8) {
				insertString(osd_vars.c2, ".", 1);
			} else {
				insertString(osd_vars.c2, ".", 2);
			}
			insertString(osd_vars.c2, "LON:", 0);
		}
		cairo_move_to(cr, buf->width - 240, buf->height - 60);
		cairo_show_text(cr,  osd_vars.c2);
		sprintf(msg, "PITCH:%.00f", osd_vars.telemetry_pitch);
		cairo_move_to(cr, x_center + 440, buf->height - 140);
		sprintf(msg, "ROLL:%.00f", osd_vars.telemetry_roll);
		cairo_move_to(cr, x_center + 440, buf->height - 170);
		sprintf(msg, "DIST:%.03fM", osd_vars.telemetry_distance);
		cairo_move_to(cr, x_center - 350, buf->height - 30);
		cairo_show_text(cr, msg);
	}
    
	sprintf(msg, "RSSI:%.00f", osd_vars.telemetry_rssi);
	cairo_move_to(cr, x_center - 50, buf->height - 30);
	cairo_show_text(cr,  msg);

	struct timespec current_timestamp;
	if (!clock_gettime(CLOCK_MONOTONIC_COARSE, &current_timestamp)) {
		double interval = getTimeInterval(&current_timestamp, &last_timestamp);
		if (osd_vars.telemetry_arm > 1700){
			seconds = seconds + interval;
		}
	}

	sprintf(msg, "TIME:%.2d:%.2d", minutes,seconds);
	cairo_move_to(cr, buf->width - 300, buf->height - 90);
	cairo_show_text(cr, msg);
	if(seconds > 59){
		seconds = 0;
		++minutes;  
	}
	if(minutes > 59){
		seconds = 0;
		minutes = 0;
	}

	cairo_fill(cr);
}

int osd_thread_signal;

typedef struct png_closure
{
	unsigned char * iter;
	unsigned int bytes_left;
} png_closure_t;

cairo_status_t on_read_png_stream(png_closure_t * closure, unsigned char * data, unsigned int length)
{
	if(length > closure->bytes_left) return CAIRO_STATUS_READ_ERROR;
	
	memcpy(data, closure->iter, length);
	closure->iter += length;
	closure->bytes_left -= length;
	return CAIRO_STATUS_SUCCESS;
}

cairo_surface_t * surface_from_embedded_png(const char * png, size_t length)
{
	int rc = -1;
	png_closure_t closure[1] = {{
		.iter = (unsigned char *)png,
		.bytes_left = (unsigned int)length,
	}};
	return cairo_image_surface_create_from_png_stream(
		(cairo_read_func_t)on_read_png_stream,
		closure);
}

void *__OSD_THREAD__(void *param) {
	osd_thread_params *p = (osd_thread_params *)param;
	Osd *osd = new Osd;
	pthread_setname_np(pthread_self(), "__OSD");

	osd->loadConfig(p->config);
	auto last_display_at = std::chrono::steady_clock::now();

	fps_icon = surface_from_embedded_png(framerate_icon, framerate_icon_length);
	lat_icon = surface_from_embedded_png(latency_icon, latency_icon_length);
	net_icon = surface_from_embedded_png(bandwidth_icon, bandwidth_icon_length);
	sdcard_icon = surface_from_embedded_png(sdcard_white_icon, sdcard_white_icon_length);

	int ret = pthread_mutex_init(&osd_mutex, NULL);
	assert(!ret);

	struct modeset_buf *buf = &p->out->osd_bufs[p->out->osd_buf_switch];
	ret = modeset_perform_modeset(p->fd, p->out, p->out->osd_request, &p->out->osd_plane,
								  buf->fb, buf->width, buf->height, osd_vars.plane_zpos);
	assert(ret >= 0);
	while (!osd_thread_signal) {
		std::unique_lock<std::mutex> lock(mtx);
		std::vector<Fact> fact_buf;
		auto since_last_display = std::chrono::steady_clock::now() - last_display_at;
		auto wait = std::chrono::milliseconds(osd_vars.refresh_frequency_ms) - since_last_display;
		bool got_fact = cv.wait_for(
					lock,
					wait,
					[/*fact_queue*/] {
						return !fact_queue.empty();
					});
		if (got_fact) {
			// thread woke up because we got a new fact(s)
			// copy all the facts to the temporary buffer to unlock the queue ASAP
			for(; !fact_queue.empty(); fact_queue.pop()) {
				SPDLOG_DEBUG("got fact {}({})", fact_queue.front().getName(), fact_queue.front().getTags());
				fact_buf.push_back(fact_queue.front());
			}
			lock.unlock();
			for (Fact fact : fact_buf) {
				osd->setFact(fact);
			}
			fact_buf.clear();
		} else {
			// thread woke up because of refresh timeout
			lock.unlock();
			SPDLOG_DEBUG("refresh OSD");
			int buf_idx = p->out->osd_buf_switch ^ 1;
			struct modeset_buf *buf = &p->out->osd_bufs[buf_idx];
			modeset_paint_buffer(buf, osd);

			int ret = pthread_mutex_lock(&osd_mutex);
			assert(!ret);	
			p->out->osd_buf_switch = buf_idx;
			ret = pthread_mutex_unlock(&osd_mutex);
			assert(!ret);
			last_display_at = std::chrono::steady_clock::now();
		}
    }
	spdlog::info("OSD thread done.");
	return nullptr;
}

void mk_tags(osd_tag *tags, int n_tags, FactTags *fact_tags) {
	osd_tag tag;
	for (int i = 0; i < n_tags; i++) {
		tag = *tags++;
		fact_tags->emplace(tag.key, tag.val);
	}
}

void publish(Fact fact) {
	//SPDLOG_DEBUG("post fact {}({})", fact.getName(), fact.getTags());
	{
		std::lock_guard<std::mutex> lock(mtx);
		fact_queue.push(fact);
	}
	cv.notify_one();
}

#ifdef __cplusplus
extern "C" {
#endif

// Batch APIs

void *osd_batch_init(uint n) {
	auto batch = new std::vector<Fact>;
	batch->reserve(n);
	return batch;
}
void osd_publish_batch(void *batch) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	{
		std::lock_guard<std::mutex> lock(mtx);
		for (Fact fact : *facts) {
			// SPDLOG_DEBUG("batch post fact {}({})", fact.getName(), fact.getTags());
			fact_queue.push(fact);
		}
	}
	delete facts;
	cv.notify_one();
};

void osd_add_bool_fact(void *batch, char const *name, osd_tag *tags, int n_tags, bool value) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	facts->push_back(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_add_int_fact(void *batch, char const *name, osd_tag *tags, int n_tags, int value) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	facts->push_back(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_add_uint_fact(void *batch, char const *name, osd_tag *tags, int n_tags, uint value) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	facts->push_back(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_add_double_fact(void *batch, char const *name, osd_tag *tags, int n_tags, double value) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	facts->push_back(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_add_str_fact(void *batch, char const *name, osd_tag *tags, int n_tags, char *value) {
	std::vector<Fact> *facts = static_cast<std::vector<Fact> *>(batch);
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	facts->push_back(Fact(FactMeta(std::string(name), fact_tags), std::string(value)));
};


// Individual APIs

void osd_publish_bool_fact(char const *name, osd_tag *tags, int n_tags, bool value) {
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	publish(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_publish_int_fact(char const *name, osd_tag *tags, int n_tags, int value) {
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	publish(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_publish_uint_fact(char const *name, osd_tag *tags, int n_tags, uint value) {
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	publish(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_publish_double_fact(char const *name, osd_tag *tags, int n_tags, double value) {
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	publish(Fact(FactMeta(std::string(name), fact_tags), value));
};

void osd_publish_str_fact(char const *name, osd_tag *tags, int n_tags, char *value) {
	FactTags fact_tags;
	mk_tags(tags, n_tags, &fact_tags);
	publish(Fact(FactMeta(std::string(name), fact_tags), std::string(value)));
};

#ifdef __cplusplus
}
#endif
